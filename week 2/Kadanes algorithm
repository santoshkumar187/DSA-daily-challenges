Definition of Kadane‚Äôs Algorithm

Kadane‚Äôs Algorithm is a dynamic programming technique used to find the maximum sum of a contiguous subarray within a 
one-dimensional array of numbers (which may include both positive and negative integers).

‚öôÔ∏è Algorithm Characteristics

Type: Dynamic Programming

Time Complexity: O(n)

Space Complexity: O(1)

Use: Finding maximum contiguous subarray sum



/*
Given an integer array arr[] (can contain positive, negative, and zero), find the maximum possible sum of a contiguous subarray.


*/


/*
function kadane(arr):
    maxSoFar = -‚àû
    currentSum = 0

    for each num in arr:
        currentSum = max(num, currentSum + num)
        maxSoFar = max(maxSoFar, currentSum)

    return maxSoFar



*/


public class Kadane {
    public static int maxSubArray(int[] nums) {
        int maxSoFar = nums[0];
        int currentSum = nums[0];

        for (int i = 1; i < nums.length; i++) {
            currentSum = Math.max(nums[i], currentSum + nums[i]);
            maxSoFar = Math.max(maxSoFar, currentSum);
        }

        return maxSoFar;
    }

    // Demo
    public static void main(String[] args) {
        int[] arr = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println("Maximum Subarray Sum = " + maxSubArray(arr)); 


    }
}


output is : 6


### üßæ **Definition of Kadane‚Äôs Algorithm**

**Kadane‚Äôs Algorithm** is a **dynamic programming technique** used to find the **maximum sum of a contiguous subarray** within a one-dimensional array of numbers (which may include both positive and negative integers).

---

### üí° **Formal Definition:**

> Kadane‚Äôs Algorithm is an efficient method to compute the **largest possible sum of a subarray** by iterating through the array once and dynamically deciding whether to extend the current subarray or start a new one.

---

### üß† **Key Idea:**

At each index `i`, the algorithm checks:

* Should we **include** the current element `arr[i]` in the existing subarray?
  **or**
* Should we **start a new subarray** beginning at `arr[i]`?

This is decided by:

```java
currentSum = max(arr[i], currentSum + arr[i]);
```

Then, we keep track of the **maximum sum found so far** using:

```java
maxSoFar = max(maxSoFar, currentSum);
```

---

### ‚öôÔ∏è **Algorithm Characteristics**

* **Type:** Dynamic Programming
* **Time Complexity:** O(n)
* **Space Complexity:** O(1)
* **Use:** Finding maximum contiguous subarray sum

---

### üß© **Example**

For array: `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`
Maximum subarray sum = **6**, from subarray `[4, -1, 2, 1]`.

---

**In short:**

> Kadane‚Äôs Algorithm efficiently finds the **maximum sum of a contiguous subarray** in **linear time** using a simple iterative approach.
