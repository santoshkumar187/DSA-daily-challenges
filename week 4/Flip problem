ü™ô The Flip Substring Problem DescriptionThe problem you are solving is a classic Data Structures and Algorithms (DSA) 
question that combines string manipulation with a well-known optimization technique (Kadane's Algorithm).
üìù Core TaskYou are given a binary string $S$ (composed only of '0's and '1's).
Your objective is to select at most one continuous substring (a segment) of $S$ and flip all the characters
within that substring (0 becomes 1, and 1 becomes 0).The goal is to choose the flip operation 
that results in the maximum possible number of '1's in the final string.
üìè Input and OutputInput: A single binary string, $S$.Output: A 1-based array (or list) containing two integers, $[L, R]$,
which are the start and end indices of the optimal substring to flip.Edge Case: If the input string $S$ is already all '1's, 
no flip can increase the count of '1's. In this case, you must return an empty array/list ([]).



import java.util.ArrayList;
import java.util.Scanner;

public class FlipSubstring {

    /**
     * Finds the 1-based indices [L, R] of the substring to flip
     * that maximizes the number of 1s (using Kadane's Algorithm).
     */
    public ArrayList<Integer> flip(String A) {
        int n = A.length();
        int maxSum = 0; // Tracks the overall maximum gain (max subarray sum).
        int currSum = 0; // Tracks the maximum gain ending at the current index.
        
        int start = 0; // The 0-based start index of the current best subarray.
        int bestL = -1, bestR = -1; // The 0-based indices for the final best flip.

        for (int i = 0; i < n; i++) {
            // Transformation: '0' -> +1 (gain), '1' -> -1 (loss)
            int val = (A.charAt(i) == '0') ? 1 : -1;

            // 1. Decide to Extend or Restart
            // If the current subarray is dragging the sum down (currSum + val < val, or currSum < 0),
            // restart the subarray from the current element.
            if (currSum + val < val) { 
                currSum = val;
                start = i;
            } else {
                // Otherwise, extend the current subarray.
                currSum += val;
            }

            // 2. Update the Global Maximum
            if (currSum > maxSum) {
                maxSum = currSum;
                bestL = start;
                bestR = i;
            }
        }

        ArrayList<Integer> ans = new ArrayList<>();
        
        // If bestL is -1, no beneficial flip (gain > 0) was found.
        if (bestL == -1) {
            return ans; // Returns empty list []
        }

        // Convert 0-based indices to 1-based indices
        ans.add(bestL + 1); 
        ans.add(bestR + 1);
        return ans;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter the binary string (0s and 1s):");
        
        // Read user input
        String inputString = scanner.next();
        scanner.close();

        FlipSubstring solver = new FlipSubstring();
        ArrayList<Integer> result = solver.flip(inputString);
        
        System.out.println("\n--- Result ---");
        System.out.println("Input String: " + inputString);
        
        if (result.isEmpty()) {
            System.out.println("Output (1-based indices): [] (No flip is beneficial)");
        } else {
            System.out.println("Output (1-based indices): " + result);
            System.out.println("This means flipping the substring from index " + result.get(0) + 
                               " to " + result.get(1) + " (inclusive) maximizes the 1s.");
        }
    }
}



output

Enter the binary string (0s and 1s):
101

--- Result ---
Input String: 101
Output (1-based indices): [2, 2]
This means flipping the substring from index 2 to 2 (inclusive) maximizes the 1s.

=== Code Execution Successful ===



or




/*
You are given a binary string s (only '0' and '1').
You may choose at most one substring and flip all its characters (0 ‚Üí 1, 1 ‚Üí 0).

Your task is to return the 1-based indices [L, R] of the substring that maximizes the number of 1s in the final string.

If the string is already all 1s, return an empty array.
Input: "010"
Output: [1, 1]

Explanation:
Flipping the first bit ‚Üí "110", which has maximum 1s.


*/


/*
function flip(s):
    arr = []
    for ch in s:
        if ch == '0':
            arr.append(1)
        else:
            arr.append(-1)

    maxSum = 0
    currentSum = 0
    L = R = start = 0
    for i in range(len(arr)):
        if currentSum + arr[i] < arr[i]:
            currentSum = arr[i]
            start = i
        else:
            currentSum += arr[i]

        if currentSum > maxSum:
            maxSum = currentSum
            L = start
            R = i

    if maxSum <= 0:
        return []

    return [L+1, R+1]   # 1-based index



*/

import java.util.*;

class Solution {
    public ArrayList<Integer> flip(String A) {
        int n = A.length();
        int maxSum = 0, currSum = 0;
        int l = 0, r = 0, start = 0;
        int bestL = -1, bestR = -1;

        for (int i = 0; i < n; i++) {
            int val = (A.charAt(i) == '0') ? 1 : -1;

            if (currSum + val < val) {
                currSum = val;
                start = i;
            } else {
                currSum += val;
            }

            if (currSum > maxSum) {
                maxSum = currSum;
                bestL = start;
                bestR = i;
            }
        }

        ArrayList<Integer> ans = new ArrayList<>();
        if (bestL == -1) return ans; // all 1s
        ans.add(bestL + 1); // convert to 1-based
        ans.add(bestR + 1);
        return ans;
    }
}
